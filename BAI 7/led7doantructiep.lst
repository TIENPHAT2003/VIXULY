CCS PCM C Compiler, Version 5.112, 43599               18-Oct-23 10:10

               Filename:   C:\Users\defaultuser0.LAPTOP-POTNR7PE\OneDrive - hcmute.edu.vn\Desktop\VXL\BAI 7\led7doantructiep.lst

               ROM used:   1657 words (20%)
                           Largest free fragment is 2048
               RAM used:   26 (7%) at main() level
                           37 (10%) worst case
               Stack used: 0 locations
               Stack size: 8

*
0000:  MOVLW  05
0001:  MOVWF  0A
0002:  GOTO   5D6
0003:  NOP
.................... #include<16f887.h>
.................... //////////// Standard Header file for the PIC16F887 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F887
0004:  DATA C8,27
0005:  DATA 20,2A
0006:  DATA 45,27
0007:  DATA 3A,10
0008:  DATA D6,2A
0009:  DATA 20,2A
000A:  DATA C9,22
000B:  DATA 4E,10
000C:  DATA 50,24
000D:  DATA 41,2A
000E:  DATA 00,00
000F:  DATA CD,29
0010:  DATA 53,2B
0011:  DATA 3A,10
0012:  DATA B2,18
0013:  DATA B1,1A
0014:  DATA B1,19
0015:  DATA B0,1C
0016:  DATA 00,01
0017:  DATA D3,20
0018:  DATA CE,23
0019:  DATA 20,2A
001A:  DATA 41,2A
001B:  DATA 00,01
001C:  DATA D3,20
001D:  DATA CE,23
001E:  DATA 20,22
001F:  DATA 41,27
0020:  DATA A0,29
0021:  DATA 41,27
0022:  DATA 47,10
0023:  DATA 50,24
0024:  DATA C1,24
0025:  DATA 00,01
0026:  DATA D3,20
0027:  DATA CE,23
0028:  DATA 20,22
0029:  DATA 41,27
002A:  DATA A0,29
002B:  DATA 41,27
002C:  DATA 47,10
002D:  DATA 54,29
002E:  DATA C1,24
002F:  DATA 00,01
0030:  DATA D4,20
0031:  DATA 54,10
0032:  DATA C4,20
0033:  DATA 4E,10
0034:  DATA D3,20
0035:  DATA CE,23
0036:  DATA 20,2A
0037:  DATA D2,20
0038:  DATA 49,00
0039:  DATA D4,20
003A:  DATA 54,10
003B:  DATA C4,20
003C:  DATA 4E,10
003D:  DATA D3,20
003E:  DATA CE,23
003F:  DATA 20,28
0040:  DATA C8,20
0041:  DATA 49,00
0042:  DATA D3,20
0043:  DATA CE,23
0044:  DATA 20,2A
0045:  DATA D2,27
0046:  DATA CE,23
0047:  DATA 20,29
0048:  DATA 41,00
0049:  DATA D3,20
004A:  DATA CE,23
004B:  DATA 20,27
004C:  DATA C7,27
004D:  DATA C1,24
004E:  DATA 20,2B
004F:  DATA C1,27
0050:  DATA 00,01
0051:  DATA D4,20
0052:  DATA 54,10
0053:  DATA CE,23
0054:  DATA CF,20
0055:  DATA 49,10
0056:  DATA D6,20
0057:  DATA 4F,00
0058:  DATA D4,20
0059:  DATA 54,10
005A:  DATA 54,29
005B:  DATA 4F,27
005C:  DATA 47,10
005D:  DATA D2,20
005E:  DATA 00,01
005F:  DATA DA,24
0060:  DATA 43,24
0061:  DATA 20,2D
0062:  DATA C1,21
0063:  DATA 00,00
0064:  DATA D3,27
0065:  DATA 20,29
0066:  DATA 41,27
0067:  DATA C4,27
0068:  DATA 4D,1D
0069:  DATA A0,12
006A:  DATA EC,3A
006B:  DATA 00,00
006C:  DATA D3,27
006D:  DATA 20,29
006E:  DATA 41,27
006F:  DATA C4,27
0070:  DATA 4D,1D
0071:  DATA A0,12
0072:  DATA EC,3A
0073:  DATA 00,00
0074:  DATA C8,27
0075:  DATA 20,2A
0076:  DATA 45,27
0077:  DATA 3A,10
0078:  DATA D6,2A
0079:  DATA 20,2A
007A:  DATA C9,22
007B:  DATA 4E,10
007C:  DATA 50,24
007D:  DATA 41,2A
007E:  DATA 00,01
007F:  DATA CD,29
0080:  DATA 53,2B
0081:  DATA 3A,10
0082:  DATA B2,18
0083:  DATA B1,1A
0084:  DATA B1,19
0085:  DATA B0,1C
0086:  DATA 00,01
0087:  DATA 4B,24
0088:  DATA 4F,27
0089:  DATA 47,10
008A:  DATA C3,27
008B:  DATA 20,2A
008C:  DATA D2,20
008D:  DATA CE,23
008E:  DATA 20,2A
008F:  DATA C8,20
0090:  DATA 49,00
0091:  DATA D3,27
0092:  DATA 20,29
0093:  DATA 41,27
0094:  DATA C4,27
0095:  DATA 4D,1D
0096:  DATA A0,12
0097:  DATA EC,3A
0098:  DATA 00,00
*
0101:  MOVF   0B,W
0102:  MOVWF  33
0103:  BCF    0B.7
0104:  BSF    03.5
0105:  BSF    03.6
0106:  BSF    0C.7
0107:  BSF    0C.0
0108:  NOP
0109:  NOP
010A:  BCF    03.5
010B:  BCF    03.6
010C:  BTFSC  33.7
010D:  BSF    0B.7
010E:  BSF    03.6
010F:  MOVF   0C,W
0110:  ANDLW  7F
0111:  BTFSC  03.2
0112:  GOTO   155
0113:  BCF    03.6
0114:  MOVWF  33
0115:  BSF    03.6
0116:  MOVF   0D,W
0117:  BCF    03.6
0118:  MOVWF  34
0119:  BSF    03.6
011A:  MOVF   0F,W
011B:  BCF    03.6
011C:  MOVWF  35
011D:  MOVF   33,W
011E:  MOVWF  3E
011F:  CALL   0DF
0120:  MOVF   34,W
0121:  BSF    03.6
0122:  MOVWF  0D
0123:  BCF    03.6
0124:  MOVF   35,W
0125:  BSF    03.6
0126:  MOVWF  0F
0127:  BCF    03.6
0128:  MOVF   0B,W
0129:  MOVWF  36
012A:  BCF    0B.7
012B:  BSF    03.5
012C:  BSF    03.6
012D:  BSF    0C.7
012E:  BSF    0C.0
012F:  NOP
0130:  NOP
0131:  BCF    03.5
0132:  BCF    03.6
0133:  BTFSC  36.7
0134:  BSF    0B.7
0135:  BSF    03.6
0136:  RLF    0C,W
0137:  RLF    0E,W
0138:  ANDLW  7F
0139:  BTFSC  03.2
013A:  GOTO   155
013B:  BCF    03.6
013C:  MOVWF  33
013D:  BSF    03.6
013E:  MOVF   0D,W
013F:  BCF    03.6
0140:  MOVWF  34
0141:  BSF    03.6
0142:  MOVF   0F,W
0143:  BCF    03.6
0144:  MOVWF  35
0145:  MOVF   33,W
0146:  MOVWF  3E
0147:  CALL   0DF
0148:  MOVF   34,W
0149:  BSF    03.6
014A:  MOVWF  0D
014B:  BCF    03.6
014C:  MOVF   35,W
014D:  BSF    03.6
014E:  MOVWF  0F
014F:  INCF   0D,F
0150:  BTFSC  03.2
0151:  INCF   0F,F
0152:  BCF    03.6
0153:  GOTO   101
0154:  BSF    03.6
0155:  BCF    03.6
0156:  RETURN
0157:  CLRF   78
0158:  CLRF   79
0159:  CLRF   77
015A:  CLRF   7A
015B:  MOVF   39,W
015C:  BTFSS  03.2
015D:  GOTO   161
015E:  MOVF   38,W
015F:  BTFSC  03.2
0160:  GOTO   17B
0161:  MOVLW  10
0162:  MOVWF  3A
0163:  BCF    03.0
0164:  RLF    36,F
0165:  RLF    37,F
0166:  RLF    77,F
0167:  RLF    7A,F
0168:  MOVF   39,W
0169:  SUBWF  7A,W
016A:  BTFSS  03.2
016B:  GOTO   16E
016C:  MOVF   38,W
016D:  SUBWF  77,W
016E:  BTFSS  03.0
016F:  GOTO   177
0170:  MOVF   38,W
0171:  SUBWF  77,F
0172:  BTFSS  03.0
0173:  DECF   7A,F
0174:  MOVF   39,W
0175:  SUBWF  7A,F
0176:  BSF    03.0
0177:  RLF    78,F
0178:  RLF    79,F
0179:  DECFSZ 3A,F
017A:  GOTO   163
017B:  RETURN
*
018C:  MOVLW  20
018D:  MOVWF  3F
018E:  CLRF   3B
018F:  CLRF   3C
0190:  CLRF   3D
0191:  CLRF   3E
0192:  MOVF   36,W
0193:  MOVWF  7A
0194:  MOVF   35,W
0195:  MOVWF  79
0196:  MOVF   34,W
0197:  MOVWF  78
0198:  MOVF   33,W
0199:  MOVWF  77
019A:  BCF    03.0
019B:  BTFSS  77.0
019C:  GOTO   1AB
019D:  MOVF   37,W
019E:  ADDWF  3B,F
019F:  MOVF   38,W
01A0:  BTFSC  03.0
01A1:  INCFSZ 38,W
01A2:  ADDWF  3C,F
01A3:  MOVF   39,W
01A4:  BTFSC  03.0
01A5:  INCFSZ 39,W
01A6:  ADDWF  3D,F
01A7:  MOVF   3A,W
01A8:  BTFSC  03.0
01A9:  INCFSZ 3A,W
01AA:  ADDWF  3E,F
01AB:  RRF    3E,F
01AC:  RRF    3D,F
01AD:  RRF    3C,F
01AE:  RRF    3B,F
01AF:  RRF    7A,F
01B0:  RRF    79,F
01B1:  RRF    78,F
01B2:  RRF    77,F
01B3:  DECFSZ 3F,F
01B4:  GOTO   19A
*
01E2:  MOVF   0B,W
01E3:  MOVWF  36
01E4:  BCF    0B.7
01E5:  BSF    03.5
01E6:  BSF    03.6
01E7:  BSF    0C.7
01E8:  BSF    0C.0
01E9:  NOP
01EA:  NOP
01EB:  BCF    03.5
01EC:  BCF    03.6
01ED:  BTFSC  36.7
01EE:  BSF    0B.7
01EF:  BTFSC  03.0
01F0:  GOTO   219
01F1:  BSF    03.6
01F2:  MOVF   0C,W
01F3:  ANDLW  7F
01F4:  BCF    03.6
01F5:  MOVWF  36
01F6:  BSF    03.6
01F7:  MOVF   0D,W
01F8:  BCF    03.6
01F9:  MOVWF  37
01FA:  BSF    03.6
01FB:  MOVF   0F,W
01FC:  BCF    03.6
01FD:  MOVWF  38
01FE:  MOVF   36,W
01FF:  MOVWF  3E
0200:  CALL   0DF
0201:  MOVF   37,W
0202:  BSF    03.6
0203:  MOVWF  0D
0204:  BCF    03.6
0205:  MOVF   38,W
0206:  BSF    03.6
0207:  MOVWF  0F
0208:  BCF    03.6
0209:  MOVF   0B,W
020A:  MOVWF  39
020B:  BCF    0B.7
020C:  BSF    03.5
020D:  BSF    03.6
020E:  BSF    0C.7
020F:  BSF    0C.0
0210:  NOP
0211:  NOP
0212:  BCF    03.5
0213:  BCF    03.6
0214:  BTFSC  39.7
0215:  BSF    0B.7
0216:  DECFSZ 35,F
0217:  GOTO   219
0218:  GOTO   238
0219:  BSF    03.6
021A:  RLF    0C,W
021B:  RLF    0E,W
021C:  ANDLW  7F
021D:  BCF    03.6
021E:  MOVWF  36
021F:  BSF    03.6
0220:  MOVF   0D,W
0221:  BCF    03.6
0222:  MOVWF  37
0223:  BSF    03.6
0224:  MOVF   0F,W
0225:  BCF    03.6
0226:  MOVWF  38
0227:  MOVF   36,W
0228:  MOVWF  3E
0229:  CALL   0DF
022A:  MOVF   37,W
022B:  BSF    03.6
022C:  MOVWF  0D
022D:  BCF    03.6
022E:  MOVF   38,W
022F:  BSF    03.6
0230:  MOVWF  0F
0231:  INCF   0D,F
0232:  BTFSC  03.2
0233:  INCF   0F,F
0234:  BCF    03.0
0235:  BCF    03.6
0236:  DECFSZ 35,F
0237:  GOTO   1E2
0238:  RETURN
0239:  CLRF   3D
023A:  MOVF   04,W
023B:  MOVWF  3C
023C:  BCF    3D.0
023D:  BTFSC  03.7
023E:  BSF    3D.0
023F:  SWAPF  36,W
0240:  IORLW  F0
0241:  MOVWF  38
0242:  ADDWF  38,F
0243:  ADDLW  E2
0244:  MOVWF  39
0245:  ADDLW  32
0246:  MOVWF  3B
0247:  MOVF   36,W
0248:  ANDLW  0F
0249:  ADDWF  39,F
024A:  ADDWF  39,F
024B:  ADDWF  3B,F
024C:  ADDLW  E9
024D:  MOVWF  3A
024E:  ADDWF  3A,F
024F:  ADDWF  3A,F
0250:  SWAPF  35,W
0251:  ANDLW  0F
0252:  ADDWF  3A,F
0253:  ADDWF  3B,F
0254:  RLF    3A,F
0255:  RLF    3B,F
0256:  COMF   3B,F
0257:  RLF    3B,F
0258:  MOVF   35,W
0259:  ANDLW  0F
025A:  ADDWF  3B,F
025B:  RLF    38,F
025C:  MOVLW  07
025D:  MOVWF  37
025E:  MOVLW  0A
025F:  ADDWF  3B,F
0260:  DECF   3A,F
0261:  BTFSS  03.0
0262:  GOTO   25F
0263:  ADDWF  3A,F
0264:  DECF   39,F
0265:  BTFSS  03.0
0266:  GOTO   263
0267:  ADDWF  39,F
0268:  DECF   38,F
0269:  BTFSS  03.0
026A:  GOTO   267
026B:  ADDWF  38,F
026C:  DECF   37,F
026D:  BTFSS  03.0
026E:  GOTO   26B
026F:  MOVLW  37
0270:  MOVWF  04
0271:  BCF    03.7
0272:  MOVLW  07
0273:  ANDWF  3C,W
0274:  BCF    3C.6
0275:  ADDWF  04,F
0276:  MOVLW  3B
0277:  SUBWF  04,W
0278:  BTFSC  03.2
0279:  BSF    3C.6
027A:  MOVF   00,W
027B:  MOVWF  77
027C:  BTFSS  03.2
027D:  GOTO   286
027E:  BTFSC  3C.6
027F:  GOTO   286
0280:  BTFSC  3C.4
0281:  GOTO   298
0282:  BTFSC  3C.3
0283:  GOTO   286
0284:  MOVLW  20
0285:  GOTO   289
0286:  BSF    3C.3
0287:  BCF    3C.4
0288:  MOVLW  30
0289:  ADDWF  77,F
028A:  CLRF   36
028B:  MOVF   04,W
028C:  MOVWF  35
028D:  BCF    36.0
028E:  BTFSC  03.7
028F:  BSF    36.0
0290:  MOVF   77,W
0291:  MOVWF  3E
0292:  CALL   0DF
0293:  MOVF   35,W
0294:  MOVWF  04
0295:  BCF    03.7
0296:  BTFSC  36.0
0297:  BSF    03.7
0298:  INCF   04,F
0299:  BTFSS  3C.6
029A:  GOTO   276
029B:  RETURN
.................... 
.................... #list
.................... 
.................... #fuses intrc_io
.................... #use delay(clock=8M)
*
00BB:  MOVLW  33
00BC:  MOVWF  04
00BD:  BCF    03.7
00BE:  MOVF   00,W
00BF:  BTFSC  03.2
00C0:  GOTO   0CE
00C1:  MOVLW  02
00C2:  MOVWF  78
00C3:  CLRF   77
00C4:  DECFSZ 77,F
00C5:  GOTO   0C4
00C6:  DECFSZ 78,F
00C7:  GOTO   0C3
00C8:  MOVLW  97
00C9:  MOVWF  77
00CA:  DECFSZ 77,F
00CB:  GOTO   0CA
00CC:  DECFSZ 00,F
00CD:  GOTO   0C1
00CE:  RETURN
.................... signed int8 i,dem=0;
.................... unsigned int32 y,n;
.................... 
.................... #define lcd_rs pin_c5
.................... #define lcd_rw pin_c6
.................... #define lcd_e pin_c7
.................... #define output_lcd output_d
.................... #include <tv_lcd.c>
.................... void lcd_command(int8 a)
.................... {
....................       output_low(lcd_rw);
*
0099:  BCF    2A.6
009A:  MOVF   2A,W
009B:  BSF    03.5
009C:  MOVWF  07
009D:  BCF    03.5
009E:  BCF    07.6
....................       output_low(lcd_rs);
009F:  BCF    2A.5
00A0:  MOVF   2A,W
00A1:  BSF    03.5
00A2:  MOVWF  07
00A3:  BCF    03.5
00A4:  BCF    07.5
....................       output_lcd(a);
00A5:  BSF    03.5
00A6:  CLRF   08
00A7:  BCF    03.5
00A8:  MOVF   33,W
00A9:  MOVWF  08
....................       output_high(lcd_e);
00AA:  BCF    2A.7
00AB:  MOVF   2A,W
00AC:  BSF    03.5
00AD:  MOVWF  07
00AE:  BCF    03.5
00AF:  BSF    07.7
....................       output_low(lcd_e);
00B0:  BCF    2A.7
00B1:  MOVF   2A,W
00B2:  BSF    03.5
00B3:  MOVWF  07
00B4:  BCF    03.5
00B5:  BCF    07.7
....................       delay_us(200);
00B6:  MOVLW  85
00B7:  MOVWF  77
00B8:  DECFSZ 77,F
00B9:  GOTO   0B8
00BA:  RETURN
.................... }
.................... void lcd_data(int8 a)
.................... {
....................       output_low(lcd_rw);
*
00DF:  BCF    2A.6
00E0:  MOVF   2A,W
00E1:  BSF    03.5
00E2:  MOVWF  07
00E3:  BCF    03.5
00E4:  BCF    07.6
....................       output_high(lcd_rs);
00E5:  BCF    2A.5
00E6:  MOVF   2A,W
00E7:  BSF    03.5
00E8:  MOVWF  07
00E9:  BCF    03.5
00EA:  BSF    07.5
....................       output_lcd(a);
00EB:  BSF    03.5
00EC:  CLRF   08
00ED:  BCF    03.5
00EE:  MOVF   3E,W
00EF:  MOVWF  08
....................       output_high(lcd_e);
00F0:  BCF    2A.7
00F1:  MOVF   2A,W
00F2:  BSF    03.5
00F3:  MOVWF  07
00F4:  BCF    03.5
00F5:  BSF    07.7
....................       output_low(lcd_e);
00F6:  BCF    2A.7
00F7:  MOVF   2A,W
00F8:  BSF    03.5
00F9:  MOVWF  07
00FA:  BCF    03.5
00FB:  BCF    07.7
....................       delay_us(200);
00FC:  MOVLW  85
00FD:  MOVWF  77
00FE:  DECFSZ 77,F
00FF:  GOTO   0FE
0100:  RETURN
.................... }
.................... void lcd_setup()
.................... {     
....................       lcd_command(0x38); delay_ms(5);
*
00CF:  MOVLW  38
00D0:  MOVWF  33
00D1:  CALL   099
00D2:  MOVLW  05
00D3:  MOVWF  33
00D4:  CALL   0BB
....................       lcd_command(0x0c); 
00D5:  MOVLW  0C
00D6:  MOVWF  33
00D7:  CALL   099
....................       lcd_command(0x01); delay_ms(2);
00D8:  MOVLW  01
00D9:  MOVWF  33
00DA:  CALL   099
00DB:  MOVLW  02
00DC:  MOVWF  33
00DD:  CALL   0BB
00DE:  RETURN
.................... }
.................... 
.................... #include<stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
*
05F4:  BCF    03.6
05F5:  CLRF   2B
05F6:  CLRF   2C
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
*
017C:  MOVF   30,W
017D:  MOVWF  36
017E:  MOVF   2F,W
017F:  MOVWF  35
0180:  MOVF   2E,W
0181:  MOVWF  34
0182:  MOVF   2D,W
0183:  MOVWF  33
0184:  MOVLW  41
0185:  MOVWF  3A
0186:  MOVLW  C6
0187:  MOVWF  39
0188:  MOVLW  4E
0189:  MOVWF  38
018A:  MOVLW  6D
018B:  MOVWF  37
*
01B5:  MOVLW  39
01B6:  ADDWF  77,W
01B7:  MOVWF  2D
01B8:  MOVF   78,W
01B9:  MOVWF  2E
01BA:  MOVLW  30
01BB:  BTFSC  03.0
01BC:  MOVLW  31
01BD:  ADDWF  2E,F
01BE:  MOVF   79,W
01BF:  MOVWF  2F
01C0:  MOVLW  00
01C1:  BTFSC  03.0
01C2:  MOVLW  01
01C3:  ADDWF  2F,F
01C4:  MOVF   7A,W
01C5:  MOVWF  30
01C6:  MOVLW  00
01C7:  BTFSC  03.0
01C8:  MOVLW  01
01C9:  ADDWF  30,F
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
01CA:  MOVF   2F,W
01CB:  MOVWF  77
01CC:  MOVF   30,W
01CD:  MOVWF  78
01CE:  CLRF   79
01CF:  CLRF   7A
01D0:  MOVF   30,W
01D1:  MOVWF  35
01D2:  MOVF   2F,W
01D3:  MOVWF  34
01D4:  MOVF   30,W
01D5:  MOVWF  37
01D6:  MOVF   2F,W
01D7:  MOVWF  36
01D8:  MOVLW  7F
01D9:  MOVWF  39
01DA:  MOVLW  FF
01DB:  MOVWF  38
01DC:  CALL   157
01DD:  MOVF   77,W
01DE:  MOVWF  78
01DF:  MOVF   7A,W
01E0:  MOVWF  79
01E1:  RETURN
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... void st()
.................... {
....................    output_a(0xff);
*
03A6:  BSF    03.5
03A7:  CLRF   05
03A8:  MOVLW  FF
03A9:  BCF    03.5
03AA:  MOVWF  05
....................    output_b(0xff);
03AB:  BSF    03.5
03AC:  CLRF   06
03AD:  BCF    03.5
03AE:  MOVWF  06
....................    delay_ms(200);
03AF:  MOVLW  C8
03B0:  MOVWF  33
03B1:  CALL   0BB
....................    if(input(pin_e1)==0||input(pin_e2)==0) break;
03B2:  BSF    03.5
03B3:  BSF    09.1
03B4:  BCF    03.5
03B5:  BTFSS  09.1
03B6:  GOTO   3BC
03B7:  BSF    03.5
03B8:  BSF    09.2
03B9:  BCF    03.5
03BA:  BTFSC  09.2
03BB:  GOTO   3BC
....................    output_a(0);
03BC:  BSF    03.5
03BD:  CLRF   05
03BE:  BCF    03.5
03BF:  CLRF   05
....................    output_b(0);   
03C0:  BSF    03.5
03C1:  CLRF   06
03C2:  BCF    03.5
03C3:  CLRF   06
....................    if(input(pin_e1)==0||input(pin_e2)==0) break;
03C4:  BSF    03.5
03C5:  BSF    09.1
03C6:  BCF    03.5
03C7:  BTFSS  09.1
03C8:  GOTO   3CE
03C9:  BSF    03.5
03CA:  BSF    09.2
03CB:  BCF    03.5
03CC:  BTFSC  09.2
03CD:  GOTO   3CE
03CE:  BCF    0A.3
03CF:  BCF    0A.4
03D0:  GOTO   653 (RETURN)
.................... }
.................... void stsp()
.................... {
....................    for(i=16;i>=0;i--)
03D1:  MOVLW  10
03D2:  MOVWF  20
03D3:  BTFSC  20.7
03D4:  GOTO   3FF
....................    {
....................       y=0xffff>>i;
03D5:  MOVLW  FF
03D6:  MOVWF  23
03D7:  MOVWF  22
03D8:  CLRF   24
03D9:  CLRF   25
03DA:  MOVF   20,W
03DB:  MOVWF  33
03DC:  BTFSC  03.2
03DD:  GOTO   3E5
03DE:  BCF    03.0
03DF:  RRF    25,F
03E0:  RRF    24,F
03E1:  RRF    23,F
03E2:  RRF    22,F
03E3:  DECFSZ 33,F
03E4:  GOTO   3DE
....................       // 8led 1111 1111 >>8 = 0000 0000 >>7 0000 0001
....................       output_a(y);
03E5:  BSF    03.5
03E6:  CLRF   05
03E7:  BCF    03.5
03E8:  MOVF   22,W
03E9:  MOVWF  05
....................       output_b(y>>8);
03EA:  CLRF   37
03EB:  BSF    03.5
03EC:  CLRF   06
03ED:  BCF    03.5
03EE:  MOVF   23,W
03EF:  MOVWF  06
....................       delay_ms(50);
03F0:  MOVLW  32
03F1:  MOVWF  33
03F2:  CALL   0BB
....................       if(input(pin_e1)==0||input(pin_e2)==0) break;
03F3:  BSF    03.5
03F4:  BSF    09.1
03F5:  BCF    03.5
03F6:  BTFSS  09.1
03F7:  GOTO   3FC
03F8:  BSF    03.5
03F9:  BSF    09.2
03FA:  BCF    03.5
03FB:  BTFSS  09.2
03FC:  GOTO   3FF
03FD:  DECF   20,F
03FE:  GOTO   3D3
....................    }
03FF:  BCF    0A.3
0400:  BCF    0A.4
0401:  GOTO   657 (RETURN)
.................... }
.................... void spst()
.................... {
....................    for(i=16;i>=0;i--)
0402:  MOVLW  10
0403:  MOVWF  20
0404:  BTFSC  20.7
0405:  GOTO   430
....................    {
....................       y=0xffff<<i;
0406:  MOVLW  FF
0407:  MOVWF  23
0408:  MOVWF  22
0409:  CLRF   24
040A:  CLRF   25
040B:  MOVF   20,W
040C:  MOVWF  33
040D:  BTFSC  03.2
040E:  GOTO   416
040F:  BCF    03.0
0410:  RLF    22,F
0411:  RLF    23,F
0412:  RLF    24,F
0413:  RLF    25,F
0414:  DECFSZ 33,F
0415:  GOTO   40F
....................       // 8led 1111 1111 <<8 = 0000 0000 <<7 1000 0000
....................       output_a(y);
0416:  BSF    03.5
0417:  CLRF   05
0418:  BCF    03.5
0419:  MOVF   22,W
041A:  MOVWF  05
....................       output_b(y>>8);  
041B:  CLRF   37
041C:  BSF    03.5
041D:  CLRF   06
041E:  BCF    03.5
041F:  MOVF   23,W
0420:  MOVWF  06
....................       delay_ms(50);
0421:  MOVLW  32
0422:  MOVWF  33
0423:  CALL   0BB
....................       if(input(pin_e1)==0||input(pin_e2)==0) break;
0424:  BSF    03.5
0425:  BSF    09.1
0426:  BCF    03.5
0427:  BTFSS  09.1
0428:  GOTO   42D
0429:  BSF    03.5
042A:  BSF    09.2
042B:  BCF    03.5
042C:  BTFSS  09.2
042D:  GOTO   430
042E:  DECF   20,F
042F:  GOTO   404
....................    }
0430:  BCF    0A.3
0431:  BCF    0A.4
0432:  GOTO   65B (RETURN)
.................... }
.................... void tpst()
.................... {
....................    for(i=16;i>=0;i--)
0433:  MOVLW  10
0434:  MOVWF  20
0435:  BTFSC  20.7
0436:  GOTO   466
....................    {
....................       y=~(0xffff<<i);
0437:  MOVLW  FF
0438:  MOVWF  7A
0439:  MOVWF  79
043A:  MOVF   20,W
043B:  MOVWF  77
043C:  BTFSC  03.2
043D:  GOTO   443
043E:  BCF    03.0
043F:  RLF    79,F
0440:  RLF    7A,F
0441:  DECFSZ 77,F
0442:  GOTO   43E
0443:  MOVF   79,W
0444:  XORLW  FF
0445:  MOVWF  22
0446:  MOVLW  FF
0447:  XORWF  7A,W
0448:  MOVWF  23
0449:  MOVLW  FF
044A:  MOVWF  24
044B:  MOVWF  25
....................       // 8led 1111 1111 >>8 = 0000 0000 >>7 1000 0000 sau khi dao 0111 1111
....................       output_a(y);
044C:  BSF    03.5
044D:  CLRF   05
044E:  BCF    03.5
044F:  MOVF   22,W
0450:  MOVWF  05
....................       output_b(y>>8);
0451:  CLRF   37
0452:  BSF    03.5
0453:  CLRF   06
0454:  BCF    03.5
0455:  MOVF   23,W
0456:  MOVWF  06
....................       delay_ms(50);
0457:  MOVLW  32
0458:  MOVWF  33
0459:  CALL   0BB
....................       if(input(pin_e1)==0||input(pin_e2)==0) break;
045A:  BSF    03.5
045B:  BSF    09.1
045C:  BCF    03.5
045D:  BTFSS  09.1
045E:  GOTO   463
045F:  BSF    03.5
0460:  BSF    09.2
0461:  BCF    03.5
0462:  BTFSS  09.2
0463:  GOTO   466
0464:  DECF   20,F
0465:  GOTO   435
....................    }
0466:  BCF    0A.3
0467:  BCF    0A.4
0468:  GOTO   65F (RETURN)
.................... }
.................... void ttsp()
.................... {
....................    for(i=16;i>=0;i--)
0469:  MOVLW  10
046A:  MOVWF  20
046B:  BTFSC  20.7
046C:  GOTO   49C
....................    {
....................       y=~(0xffff>>i);
046D:  MOVLW  FF
046E:  MOVWF  7A
046F:  MOVWF  79
0470:  MOVF   20,W
0471:  MOVWF  77
0472:  BTFSC  03.2
0473:  GOTO   479
0474:  BCF    03.0
0475:  RRF    7A,F
0476:  RRF    79,F
0477:  DECFSZ 77,F
0478:  GOTO   474
0479:  MOVF   79,W
047A:  XORLW  FF
047B:  MOVWF  22
047C:  MOVLW  FF
047D:  XORWF  7A,W
047E:  MOVWF  23
047F:  MOVLW  FF
0480:  MOVWF  24
0481:  MOVWF  25
....................       output_a(y);
0482:  BSF    03.5
0483:  CLRF   05
0484:  BCF    03.5
0485:  MOVF   22,W
0486:  MOVWF  05
....................       output_b(y>>8);
0487:  CLRF   37
0488:  BSF    03.5
0489:  CLRF   06
048A:  BCF    03.5
048B:  MOVF   23,W
048C:  MOVWF  06
....................       delay_ms(50);
048D:  MOVLW  32
048E:  MOVWF  33
048F:  CALL   0BB
....................       if(input(pin_e1)==0||input(pin_e2)==0) break;
0490:  BSF    03.5
0491:  BSF    09.1
0492:  BCF    03.5
0493:  BTFSS  09.1
0494:  GOTO   499
0495:  BSF    03.5
0496:  BSF    09.2
0497:  BCF    03.5
0498:  BTFSS  09.2
0499:  GOTO   49C
049A:  DECF   20,F
049B:  GOTO   46B
....................    }
049C:  BCF    0A.3
049D:  BCF    0A.4
049E:  GOTO   663 (RETURN)
.................... }
.................... void strn()   // a,b sang tu phai sang trai c,d sang tu trai sang phai
.................... {
....................    for(i=8;i>=0;i--)
049F:  MOVLW  08
04A0:  MOVWF  20
04A1:  BTFSC  20.7
04A2:  GOTO   4DC
....................    {
....................       y=(0xff<<i);  
04A3:  MOVLW  FF
04A4:  MOVWF  22
04A5:  CLRF   23
04A6:  CLRF   24
04A7:  CLRF   25
04A8:  MOVF   20,W
04A9:  MOVWF  33
04AA:  BTFSC  03.2
04AB:  GOTO   4B3
04AC:  BCF    03.0
04AD:  RLF    22,F
04AE:  RLF    23,F
04AF:  RLF    24,F
04B0:  RLF    25,F
04B1:  DECFSZ 33,F
04B2:  GOTO   4AC
....................       n=(0xff>>i);
04B3:  MOVLW  FF
04B4:  MOVWF  26
04B5:  CLRF   27
04B6:  CLRF   28
04B7:  CLRF   29
04B8:  MOVF   20,W
04B9:  MOVWF  33
04BA:  BTFSC  03.2
04BB:  GOTO   4C3
04BC:  BCF    03.0
04BD:  RRF    29,F
04BE:  RRF    28,F
04BF:  RRF    27,F
04C0:  RRF    26,F
04C1:  DECFSZ 33,F
04C2:  GOTO   4BC
....................       output_a(y);
04C3:  BSF    03.5
04C4:  CLRF   05
04C5:  BCF    03.5
04C6:  MOVF   22,W
04C7:  MOVWF  05
....................       output_b(n);
04C8:  BSF    03.5
04C9:  CLRF   06
04CA:  BCF    03.5
04CB:  MOVF   26,W
04CC:  MOVWF  06
....................       delay_ms(50);
04CD:  MOVLW  32
04CE:  MOVWF  33
04CF:  CALL   0BB
....................       if(input(pin_e1)==0||input(pin_e2)==0) break;
04D0:  BSF    03.5
04D1:  BSF    09.1
04D2:  BCF    03.5
04D3:  BTFSS  09.1
04D4:  GOTO   4D9
04D5:  BSF    03.5
04D6:  BSF    09.2
04D7:  BCF    03.5
04D8:  BTFSS  09.2
04D9:  GOTO   4DC
04DA:  DECF   20,F
04DB:  GOTO   4A1
....................   }
04DC:  BCF    0A.3
04DD:  BCF    0A.4
04DE:  GOTO   667 (RETURN)
.................... }
.................... void snvt()   // a,b sang tu trai sang phai c,d sang tu pst
.................... {
....................    for(i=8;i>=0;i--)
04DF:  MOVLW  08
04E0:  MOVWF  20
04E1:  BTFSC  20.7
04E2:  GOTO   51C
....................    {
....................       y=(0xff>>i);  
04E3:  MOVLW  FF
04E4:  MOVWF  22
04E5:  CLRF   23
04E6:  CLRF   24
04E7:  CLRF   25
04E8:  MOVF   20,W
04E9:  MOVWF  33
04EA:  BTFSC  03.2
04EB:  GOTO   4F3
04EC:  BCF    03.0
04ED:  RRF    25,F
04EE:  RRF    24,F
04EF:  RRF    23,F
04F0:  RRF    22,F
04F1:  DECFSZ 33,F
04F2:  GOTO   4EC
....................       n=(0xff<<i);
04F3:  MOVLW  FF
04F4:  MOVWF  26
04F5:  CLRF   27
04F6:  CLRF   28
04F7:  CLRF   29
04F8:  MOVF   20,W
04F9:  MOVWF  33
04FA:  BTFSC  03.2
04FB:  GOTO   503
04FC:  BCF    03.0
04FD:  RLF    26,F
04FE:  RLF    27,F
04FF:  RLF    28,F
0500:  RLF    29,F
0501:  DECFSZ 33,F
0502:  GOTO   4FC
....................       output_a(y);
0503:  BSF    03.5
0504:  CLRF   05
0505:  BCF    03.5
0506:  MOVF   22,W
0507:  MOVWF  05
....................       output_b(n);
0508:  BSF    03.5
0509:  CLRF   06
050A:  BCF    03.5
050B:  MOVF   26,W
050C:  MOVWF  06
....................       delay_ms(50);
050D:  MOVLW  32
050E:  MOVWF  33
050F:  CALL   0BB
....................       if(input(pin_e1)==0||input(pin_e2)==0) break;
0510:  BSF    03.5
0511:  BSF    09.1
0512:  BCF    03.5
0513:  BTFSS  09.1
0514:  GOTO   519
0515:  BSF    03.5
0516:  BSF    09.2
0517:  BCF    03.5
0518:  BTFSS  09.2
0519:  GOTO   51C
051A:  DECF   20,F
051B:  GOTO   4E1
....................   }
051C:  BCF    0A.3
051D:  BCF    0A.4
051E:  GOTO   66B (RETURN)
....................  }
.................... void tnvt()  
.................... {
....................    for(i=8;i>=0;i--)
051F:  MOVLW  08
0520:  MOVWF  20
0521:  BTFSC  20.7
0522:  GOTO   55F
....................    {
....................       y=~(0xff>>i);  
0523:  MOVLW  FF
0524:  MOVWF  77
0525:  MOVF   20,W
0526:  MOVWF  78
0527:  BTFSC  03.2
0528:  GOTO   52D
0529:  BCF    03.0
052A:  RRF    77,F
052B:  DECFSZ 78,F
052C:  GOTO   529
052D:  MOVF   77,W
052E:  XORLW  FF
052F:  MOVWF  22
0530:  CLRF   23
0531:  DECF   23,F
0532:  MOVLW  FF
0533:  MOVWF  24
0534:  MOVWF  25
....................       n=~(0xff<<i);
0535:  MOVWF  77
0536:  MOVF   20,W
0537:  MOVWF  78
0538:  BTFSC  03.2
0539:  GOTO   53E
053A:  BCF    03.0
053B:  RLF    77,F
053C:  DECFSZ 78,F
053D:  GOTO   53A
053E:  MOVF   77,W
053F:  XORLW  FF
0540:  MOVWF  26
0541:  CLRF   27
0542:  DECF   27,F
0543:  MOVLW  FF
0544:  MOVWF  28
0545:  MOVWF  29
....................       output_a(y);
0546:  BSF    03.5
0547:  CLRF   05
0548:  BCF    03.5
0549:  MOVF   22,W
054A:  MOVWF  05
....................       output_b(n);
054B:  BSF    03.5
054C:  CLRF   06
054D:  BCF    03.5
054E:  MOVF   26,W
054F:  MOVWF  06
....................       delay_ms(50);
0550:  MOVLW  32
0551:  MOVWF  33
0552:  CALL   0BB
....................       if(input(pin_e1)==0||input(pin_e2)==0) break;
0553:  BSF    03.5
0554:  BSF    09.1
0555:  BCF    03.5
0556:  BTFSS  09.1
0557:  GOTO   55C
0558:  BSF    03.5
0559:  BSF    09.2
055A:  BCF    03.5
055B:  BTFSS  09.2
055C:  GOTO   55F
055D:  DECF   20,F
055E:  GOTO   521
....................    }
055F:  BCF    0A.3
0560:  BCF    0A.4
0561:  GOTO   66F (RETURN)
.................... }
.................... void ttrn()  
.................... {
....................    for(i=8;i>=0;i--)
0562:  MOVLW  08
0563:  MOVWF  20
0564:  BTFSC  20.7
0565:  GOTO   5A2
....................    {
....................       y=~(0xff<<i);  
0566:  MOVLW  FF
0567:  MOVWF  77
0568:  MOVF   20,W
0569:  MOVWF  78
056A:  BTFSC  03.2
056B:  GOTO   570
056C:  BCF    03.0
056D:  RLF    77,F
056E:  DECFSZ 78,F
056F:  GOTO   56C
0570:  MOVF   77,W
0571:  XORLW  FF
0572:  MOVWF  22
0573:  CLRF   23
0574:  DECF   23,F
0575:  MOVLW  FF
0576:  MOVWF  24
0577:  MOVWF  25
....................       n=~(0xff>>i);
0578:  MOVWF  77
0579:  MOVF   20,W
057A:  MOVWF  78
057B:  BTFSC  03.2
057C:  GOTO   581
057D:  BCF    03.0
057E:  RRF    77,F
057F:  DECFSZ 78,F
0580:  GOTO   57D
0581:  MOVF   77,W
0582:  XORLW  FF
0583:  MOVWF  26
0584:  CLRF   27
0585:  DECF   27,F
0586:  MOVLW  FF
0587:  MOVWF  28
0588:  MOVWF  29
....................       output_a(y);
0589:  BSF    03.5
058A:  CLRF   05
058B:  BCF    03.5
058C:  MOVF   22,W
058D:  MOVWF  05
....................       output_b(n);
058E:  BSF    03.5
058F:  CLRF   06
0590:  BCF    03.5
0591:  MOVF   26,W
0592:  MOVWF  06
....................       delay_ms(50);
0593:  MOVLW  32
0594:  MOVWF  33
0595:  CALL   0BB
....................       if(input(pin_e1)==0||input(pin_e2)==0) break;
0596:  BSF    03.5
0597:  BSF    09.1
0598:  BCF    03.5
0599:  BTFSS  09.1
059A:  GOTO   59F
059B:  BSF    03.5
059C:  BSF    09.2
059D:  BCF    03.5
059E:  BTFSS  09.2
059F:  GOTO   5A2
05A0:  DECF   20,F
05A1:  GOTO   564
....................   }
05A2:  BCF    0A.3
05A3:  BCF    0A.4
05A4:  GOTO   673 (RETURN)
....................  }
.................... void zichzac()
.................... {
....................      for(i=16;i>=0;i--)
05A5:  MOVLW  10
05A6:  MOVWF  20
05A7:  BTFSC  20.7
05A8:  GOTO   5D3
....................    {
....................       y=(0xaaaa>>i);
05A9:  MOVLW  AA
05AA:  MOVWF  23
05AB:  MOVWF  22
05AC:  CLRF   24
05AD:  CLRF   25
05AE:  MOVF   20,W
05AF:  MOVWF  33
05B0:  BTFSC  03.2
05B1:  GOTO   5B9
05B2:  BCF    03.0
05B3:  RRF    25,F
05B4:  RRF    24,F
05B5:  RRF    23,F
05B6:  RRF    22,F
05B7:  DECFSZ 33,F
05B8:  GOTO   5B2
....................       output_a(y);
05B9:  BSF    03.5
05BA:  CLRF   05
05BB:  BCF    03.5
05BC:  MOVF   22,W
05BD:  MOVWF  05
....................       output_b(y>>8);
05BE:  CLRF   37
05BF:  BSF    03.5
05C0:  CLRF   06
05C1:  BCF    03.5
05C2:  MOVF   23,W
05C3:  MOVWF  06
....................       delay_ms(100);
05C4:  MOVLW  64
05C5:  MOVWF  33
05C6:  CALL   0BB
....................       if(input(pin_e1)==0||input(pin_e2)==0) break;
05C7:  BSF    03.5
05C8:  BSF    09.1
05C9:  BCF    03.5
05CA:  BTFSS  09.1
05CB:  GOTO   5D0
05CC:  BSF    03.5
05CD:  BSF    09.2
05CE:  BCF    03.5
05CF:  BTFSS  09.2
05D0:  GOTO   5D3
05D1:  DECF   20,F
05D2:  GOTO   5A7
....................    }
05D3:  BCF    0A.3
05D4:  BCF    0A.4
05D5:  GOTO   677 (RETURN)
.................... }
.................... 
.................... void lcd_trangthai()
.................... {  
....................       lcd_setup();
*
029C:  CALL   0CF
....................       lcd_command(0x80);
029D:  MOVLW  80
029E:  MOVWF  33
029F:  CALL   099
....................       lcd_data("HO TEN: VU TIEN PHAT");
02A0:  MOVLW  04
02A1:  BSF    03.6
02A2:  MOVWF  0D
02A3:  MOVLW  00
02A4:  MOVWF  0F
02A5:  BCF    03.6
02A6:  CALL   101
....................       lcd_command(0xc0);
02A7:  MOVLW  C0
02A8:  MOVWF  33
02A9:  CALL   099
....................       lcd_data("MSSV: 21151309");
02AA:  MOVLW  0F
02AB:  BSF    03.6
02AC:  MOVWF  0D
02AD:  MOVLW  00
02AE:  MOVWF  0F
02AF:  BCF    03.6
02B0:  CALL   101
....................       lcd_command(0x94);
02B1:  MOVLW  94
02B2:  MOVWF  33
02B3:  CALL   099
....................       if(dem==1)  lcd_data("SANG TAT"); // sang tat
02B4:  DECFSZ 21,W
02B5:  GOTO   2BD
02B6:  MOVLW  17
02B7:  BSF    03.6
02B8:  MOVWF  0D
02B9:  MOVLW  00
02BA:  MOVWF  0F
02BB:  BCF    03.6
02BC:  CALL   101
....................      
....................       if(dem==2)  lcd_data("SANG DAN SANG PHAI"); // sang dan sang phai
02BD:  MOVF   21,W
02BE:  SUBLW  02
02BF:  BTFSS  03.2
02C0:  GOTO   2C8
02C1:  MOVLW  1C
02C2:  BSF    03.6
02C3:  MOVWF  0D
02C4:  MOVLW  00
02C5:  MOVWF  0F
02C6:  BCF    03.6
02C7:  CALL   101
....................      
....................       if(dem==3)  lcd_data("SANG DAN SANG TRAI"); // sang dan sang trai
02C8:  MOVF   21,W
02C9:  SUBLW  03
02CA:  BTFSS  03.2
02CB:  GOTO   2D3
02CC:  MOVLW  26
02CD:  BSF    03.6
02CE:  MOVWF  0D
02CF:  MOVLW  00
02D0:  MOVWF  0F
02D1:  BCF    03.6
02D2:  CALL   101
....................      
....................       if(dem==4)  lcd_data("TAT DAN SANG TRAI"); // tat dan sang trai
02D3:  MOVF   21,W
02D4:  SUBLW  04
02D5:  BTFSS  03.2
02D6:  GOTO   2DE
02D7:  MOVLW  30
02D8:  BSF    03.6
02D9:  MOVWF  0D
02DA:  MOVLW  00
02DB:  MOVWF  0F
02DC:  BCF    03.6
02DD:  CALL   101
....................       
....................       if(dem==5)  lcd_data("TAT DAN SANG PHAI"); // tat dan sang phai
02DE:  MOVF   21,W
02DF:  SUBLW  05
02E0:  BTFSS  03.2
02E1:  GOTO   2E9
02E2:  MOVLW  39
02E3:  BSF    03.6
02E4:  MOVWF  0D
02E5:  MOVLW  00
02E6:  MOVWF  0F
02E7:  BCF    03.6
02E8:  CALL   101
....................       
....................       if(dem==6)  lcd_data("SANG TRONG RA");; // sang trong ra
02E9:  MOVF   21,W
02EA:  SUBLW  06
02EB:  BTFSS  03.2
02EC:  GOTO   2F4
02ED:  MOVLW  42
02EE:  BSF    03.6
02EF:  MOVWF  0D
02F0:  MOVLW  00
02F1:  MOVWF  0F
02F2:  BCF    03.6
02F3:  CALL   101
....................       
....................       if(dem==7)  lcd_data("SANG NGOAI VAO"); // sang ngoai vao
02F4:  MOVF   21,W
02F5:  SUBLW  07
02F6:  BTFSS  03.2
02F7:  GOTO   2FF
02F8:  MOVLW  49
02F9:  BSF    03.6
02FA:  MOVWF  0D
02FB:  MOVLW  00
02FC:  MOVWF  0F
02FD:  BCF    03.6
02FE:  CALL   101
....................       
....................       if(dem==8)  lcd_data("TAT NGOAI VAO"); // tat ngoai vao
02FF:  MOVF   21,W
0300:  SUBLW  08
0301:  BTFSS  03.2
0302:  GOTO   30A
0303:  MOVLW  51
0304:  BSF    03.6
0305:  MOVWF  0D
0306:  MOVLW  00
0307:  MOVWF  0F
0308:  BCF    03.6
0309:  CALL   101
....................      
....................       if(dem==9)  lcd_data("TAT TRONG RA"); // tat trong ra
030A:  MOVF   21,W
030B:  SUBLW  09
030C:  BTFSS  03.2
030D:  GOTO   315
030E:  MOVLW  58
030F:  BSF    03.6
0310:  MOVWF  0D
0311:  MOVLW  00
0312:  MOVWF  0F
0313:  BCF    03.6
0314:  CALL   101
....................       
....................       if(dem==10) lcd_data("ZICH ZAC"); // zich zac
0315:  MOVF   21,W
0316:  SUBLW  0A
0317:  BTFSS  03.2
0318:  GOTO   320
0319:  MOVLW  5F
031A:  BSF    03.6
031B:  MOVWF  0D
031C:  MOVLW  00
031D:  MOVWF  0F
031E:  BCF    03.6
031F:  CALL   101
0320:  RETURN
.................... }
.................... void nutnhan()
.................... {
....................    if(input(pin_e1)==0)
0321:  BSF    03.5
0322:  BSF    09.1
0323:  BCF    03.5
0324:  BTFSC  09.1
0325:  GOTO   362
....................    {
....................       delay_ms(20);
0326:  MOVLW  14
0327:  MOVWF  33
0328:  CALL   0BB
....................       if(input(pin_e1)==0)
0329:  BSF    03.5
032A:  BSF    09.1
032B:  BCF    03.5
032C:  BTFSC  09.1
032D:  GOTO   362
....................       {
....................          dem++;
032E:  INCF   21,F
....................          if(dem>10) dem = 1;
032F:  BTFSC  21.7
0330:  GOTO   337
0331:  MOVF   21,W
0332:  SUBLW  0A
0333:  BTFSC  03.0
0334:  GOTO   337
0335:  MOVLW  01
0336:  MOVWF  21
....................          lcd_trangthai();
0337:  CALL   29C
....................          lcd_command(0xd4);
0338:  MOVLW  D4
0339:  MOVWF  33
033A:  CALL   099
....................          printf(lcd_data, "SO RANDOM: %lu", rand()%100);
033B:  CALL   17C
033C:  MOVF   79,W
033D:  MOVWF  34
033E:  MOVF   78,W
033F:  MOVWF  33
0340:  MOVF   79,W
0341:  MOVWF  37
0342:  MOVF   78,W
0343:  MOVWF  36
0344:  CLRF   39
0345:  MOVLW  64
0346:  MOVWF  38
0347:  CALL   157
0348:  MOVF   77,W
0349:  MOVWF  33
034A:  MOVF   7A,W
034B:  MOVWF  34
034C:  MOVLW  64
034D:  BSF    03.6
034E:  MOVWF  0D
034F:  MOVLW  00
0350:  MOVWF  0F
0351:  BCF    03.0
0352:  MOVLW  0B
0353:  BCF    03.6
0354:  MOVWF  35
0355:  CALL   1E2
0356:  MOVLW  10
0357:  MOVWF  04
0358:  MOVF   34,W
0359:  MOVWF  36
035A:  MOVF   33,W
035B:  MOVWF  35
035C:  CALL   239
....................          while(input(pin_e1)==0);
035D:  BSF    03.5
035E:  BSF    09.1
035F:  BCF    03.5
0360:  BTFSS  09.1
0361:  GOTO   35D
....................       }
....................    }
....................    if(input(pin_e2)==0)
0362:  BSF    03.5
0363:  BSF    09.2
0364:  BCF    03.5
0365:  BTFSC  09.2
0366:  GOTO   3A3
....................    {
....................       delay_ms(20);
0367:  MOVLW  14
0368:  MOVWF  33
0369:  CALL   0BB
....................       if(input(pin_e2)==0)
036A:  BSF    03.5
036B:  BSF    09.2
036C:  BCF    03.5
036D:  BTFSC  09.2
036E:  GOTO   3A3
....................       {
....................          dem--;
036F:  DECF   21,F
....................          if(dem < 1) dem = 10;
0370:  BTFSC  21.7
0371:  GOTO   376
0372:  MOVF   21,W
0373:  SUBLW  00
0374:  BTFSS  03.0
0375:  GOTO   378
0376:  MOVLW  0A
0377:  MOVWF  21
....................          lcd_trangthai();
0378:  CALL   29C
....................          lcd_command(0xd4);
0379:  MOVLW  D4
037A:  MOVWF  33
037B:  CALL   099
....................          printf(lcd_data, "SO RANDOM: %lu", rand()%100);
037C:  CALL   17C
037D:  MOVF   79,W
037E:  MOVWF  34
037F:  MOVF   78,W
0380:  MOVWF  33
0381:  MOVF   79,W
0382:  MOVWF  37
0383:  MOVF   78,W
0384:  MOVWF  36
0385:  CLRF   39
0386:  MOVLW  64
0387:  MOVWF  38
0388:  CALL   157
0389:  MOVF   77,W
038A:  MOVWF  33
038B:  MOVF   7A,W
038C:  MOVWF  34
038D:  MOVLW  6C
038E:  BSF    03.6
038F:  MOVWF  0D
0390:  MOVLW  00
0391:  MOVWF  0F
0392:  BCF    03.0
0393:  MOVLW  0B
0394:  BCF    03.6
0395:  MOVWF  35
0396:  CALL   1E2
0397:  MOVLW  10
0398:  MOVWF  04
0399:  MOVF   34,W
039A:  MOVWF  36
039B:  MOVF   33,W
039C:  MOVWF  35
039D:  CALL   239
....................          while(input(pin_e2)==0);
039E:  BSF    03.5
039F:  BSF    09.2
03A0:  BCF    03.5
03A1:  BTFSS  09.2
03A2:  GOTO   39E
....................       }
....................    }
03A3:  BCF    0A.3
03A4:  BCF    0A.4
03A5:  GOTO   650 (RETURN)
.................... }
.................... 
.................... void main()
*
05D6:  MOVF   03,W
05D7:  ANDLW  1F
05D8:  MOVWF  03
05D9:  MOVLW  71
05DA:  BSF    03.5
05DB:  MOVWF  0F
05DC:  CLRF   10
05DD:  MOVF   0F,W
05DE:  BCF    03.5
05DF:  CLRF   21
05E0:  MOVLW  FF
05E1:  MOVWF  2A
05E2:  CLRF   32
05E3:  CLRF   31
05E4:  BSF    03.5
05E5:  BSF    03.6
05E6:  MOVF   09,W
05E7:  ANDLW  C0
05E8:  MOVWF  09
05E9:  BCF    03.6
05EA:  BCF    1F.4
05EB:  BCF    1F.5
05EC:  MOVLW  00
05ED:  BSF    03.6
05EE:  MOVWF  08
05EF:  BCF    03.5
05F0:  CLRF   07
05F1:  CLRF   08
05F2:  CLRF   09
05F3:  BCF    03.7
.................... {  set_tris_a(0);
*
05F7:  MOVLW  00
05F8:  BSF    03.5
05F9:  MOVWF  05
....................    set_tris_b(0);
05FA:  MOVWF  06
....................    set_tris_c(0);
05FB:  MOVWF  07
05FC:  BCF    03.5
05FD:  MOVWF  2A
....................    set_tris_d(0);
05FE:  BSF    03.5
05FF:  MOVWF  08
....................    set_tris_e(0xff);
0600:  BSF    09.0
0601:  BSF    09.1
0602:  BSF    09.2
0603:  BSF    09.3
....................    output_a(0);
0604:  CLRF   05
0605:  BCF    03.5
0606:  CLRF   05
....................    output_b(0);
0607:  BSF    03.5
0608:  CLRF   06
0609:  BCF    03.5
060A:  CLRF   06
....................    lcd_setup();
060B:  CALL   0CF
....................    lcd_command(0x80);
060C:  MOVLW  80
060D:  MOVWF  33
060E:  CALL   099
....................    lcd_data("HO TEN: VU TIEN PHAT");
060F:  MOVLW  74
0610:  BSF    03.6
0611:  MOVWF  0D
0612:  MOVLW  00
0613:  MOVWF  0F
0614:  BCF    03.6
0615:  CALL   101
....................    lcd_command(0xc0);
0616:  MOVLW  C0
0617:  MOVWF  33
0618:  CALL   099
....................    lcd_data("MSSV: 21151309");
0619:  MOVLW  7F
061A:  BSF    03.6
061B:  MOVWF  0D
061C:  MOVLW  00
061D:  MOVWF  0F
061E:  BCF    03.6
061F:  CALL   101
....................    lcd_command(0x94);
0620:  MOVLW  94
0621:  MOVWF  33
0622:  CALL   099
....................    lcd_data("KHONG CO TRANG THAI");
0623:  MOVLW  87
0624:  BSF    03.6
0625:  MOVWF  0D
0626:  MOVLW  00
0627:  MOVWF  0F
0628:  BCF    03.6
0629:  CALL   101
....................    lcd_command(0xd4);
062A:  MOVLW  D4
062B:  MOVWF  33
062C:  CALL   099
....................    printf(lcd_data, "SO RANDOM: %lu", rand()%100);
062D:  CALL   17C
062E:  MOVF   79,W
062F:  MOVWF  34
0630:  MOVF   78,W
0631:  MOVWF  33
0632:  MOVF   79,W
0633:  MOVWF  37
0634:  MOVF   78,W
0635:  MOVWF  36
0636:  CLRF   39
0637:  MOVLW  64
0638:  MOVWF  38
0639:  CALL   157
063A:  MOVF   77,W
063B:  MOVWF  33
063C:  MOVF   7A,W
063D:  MOVWF  34
063E:  MOVLW  91
063F:  BSF    03.6
0640:  MOVWF  0D
0641:  MOVLW  00
0642:  MOVWF  0F
0643:  BCF    03.0
0644:  MOVLW  0B
0645:  BCF    03.6
0646:  MOVWF  35
0647:  CALL   1E2
0648:  MOVLW  10
0649:  MOVWF  04
064A:  MOVF   34,W
064B:  MOVWF  36
064C:  MOVF   33,W
064D:  MOVWF  35
064E:  CALL   239
....................    while(true)
....................    {  
....................       nutnhan();
064F:  GOTO   321
....................       if(dem==1)  st(); // sang tat
0650:  DECFSZ 21,W
0651:  GOTO   653
0652:  GOTO   3A6
....................      
....................       if(dem==2)  stsp(); // sang dan sang phai
0653:  MOVF   21,W
0654:  SUBLW  02
0655:  BTFSC  03.2
0656:  GOTO   3D1
....................      
....................       if(dem==3)  spst(); // sang dan sang trai
0657:  MOVF   21,W
0658:  SUBLW  03
0659:  BTFSC  03.2
065A:  GOTO   402
....................      
....................       if(dem==4)  tpst(); // tat dan sang trai
065B:  MOVF   21,W
065C:  SUBLW  04
065D:  BTFSC  03.2
065E:  GOTO   433
....................       
....................       if(dem==5)  ttsp(); // tat dan sang phai
065F:  MOVF   21,W
0660:  SUBLW  05
0661:  BTFSC  03.2
0662:  GOTO   469
....................       
....................       if(dem==6)  strn(); // sang trong ra
0663:  MOVF   21,W
0664:  SUBLW  06
0665:  BTFSC  03.2
0666:  GOTO   49F
....................       
....................       if(dem==7)  snvt(); // sang ngoai vao
0667:  MOVF   21,W
0668:  SUBLW  07
0669:  BTFSC  03.2
066A:  GOTO   4DF
....................       
....................       if(dem==8)  tnvt(); // tat ngoai vao
066B:  MOVF   21,W
066C:  SUBLW  08
066D:  BTFSC  03.2
066E:  GOTO   51F
....................      
....................       if(dem==9)  ttrn(); // tat trong ra
066F:  MOVF   21,W
0670:  SUBLW  09
0671:  BTFSC  03.2
0672:  GOTO   562
....................       
....................       if(dem==10) zichzac(); // zich zac
0673:  MOVF   21,W
0674:  SUBLW  0A
0675:  BTFSC  03.2
0676:  GOTO   5A5
0677:  GOTO   64F
....................    }
.................... }
0678:  SLEEP

Configuration Fuses:
   Word  1: 2FE4   INTRC_IO NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
